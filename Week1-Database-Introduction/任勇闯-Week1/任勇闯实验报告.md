 # 实验一 MySQL的安装和使用

 我的基本操作环境是使用Xshell软件进行远程操作阿里云服务器，该服务器安装的是Ubuntu操作系统。下载Docker并管理实验所需要的环境。

## Part1：使用Docker安装下载MySql
 * 使用Docker从中央仓库下载mysql镜像
 	> docker pull mysql
 * 拉取成功后可以查看镜像
	> docker images
 * 创建一个mysql容器
	> docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysqlserver mysql
 * 查看当前运行的容器
	> docker ps
 * 进入容器即可对mysql进行操作
	> docker exec -it  mysqlserver /bin/bash
 * 使用mysql
	> mysql -h localhost -u root -p 
 * 使得mysql可以远程访问
	```sql
	#修改加密mysql规则
	ALTER USER 'root'@'%' IDENTIFIED BY '123456' PASSWORD EXPIRE NEVER;
	#更新远程访问用户密码
	ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456';
	#刷新权限
	FLUSH PRIVILEGES;
	```
 ## Part2：MySql的基本操作
 ### Step1：创建一个数据库
 1. mysql系统自带四个数据库
	> information_schema：主要存储了系统中的一些数据库对象信息。比如用户表信息、列信息、权限信息、字符集信息、分区信息等。
	>
	> performance_schema：用于监控MySQL Server在一个较低级别的运行过程中的资源消耗、资源等待等情况。
	>
	> mysql：存储了系统的用户权限信息。
	>
	>sys：多为performance_schema的视图，更加方便了解数据库运行情况
 2. 数据库操作语法（实验部分）
	 ```sql
	 #创建一个名为school的数据库
	 create database school;
	 #展示数据库
	 show databases;
	 #使用数据库school;会显示“database changed”提示
	 use school;	
	 #若要删除数据库
	 drop database school;
	 ```

 ### Step2：创建一个学生表和一张学生信息表
 1. 在school数据库中创建一张学生表和一张学生信息表
	```sql
	#创建一张学生表名为student
	create table student(
	  `id`  int(11),
	  `name`  varchar(20),
	  `age` int(11)
	)default charset='utf8';

	#创建一张学生信息表studentInfo
	create table studentInfo(
	  `id`  int(11),
	  `city`  varchar(20),
	  `love`  varchar(50),
	  `grade`  float(10)	 
	)default charset='utf8';
	```
 2. 表结构的其他操作
	```sql
	#查询数据库中所有数据表
	show tables;
	#查看具体数据表的详情信息
	show create table 表名;
	#查看表的具体字段信息
	desc 表名;
	#删除数据表
	drop table 表名；
	```

 ### Step3：增加信息
 1. 单条信息插入
	```sql
	#为学生表插入一个学生
	insert into student (id,name,age)values(20200001,"王二小",18);
	#若所有字段均插入信息，则可简写
	insert into student values(20200002,"marry",16);
	#所插入信息符合表规则下可以不全，则未填写的字段为NULL;
	insert into student (id,name)values(20200003,"jack");
	```
 2. 一次插入多条数据
	```sql
	#为学生信息表插入多条数据
	insert into studentInfo (id,city,love,grade)values(20200001,"chengdu","baskeball",98.50),(20200002,"xian","swimming",80.98),(20200003,"changsha","run",90.00);
	```
 3. 赋值式插入信息
	```sql
	#为student表插入信息,支持部分信息不赋值
	insert into student set id=20200004, name="baby", age=17;
	```

 ### Step4：查询信息
 1. 基本查询
	```sql
	#查询一张表的所有信息
	select * from 表名;
	#查询某个字段或多个字段
	select id,love from studentInfo;
	```
 2. 条件查询
	```sql
	#使用where关键字来限制条件
	#查询学生表中id为20200004的学生信息
	select * from student where id=20200004;
	#双表查询
	#查询student表和studentInfo表中均id=20200002的信息
	select * from student,studentInfo where student.id=20200002 and student.id=studentInfo.id;
	#在上一条语句基础上，使得展示指定字段
	select student.id,name,love from student,studentInfo where student.id=20200002 and student.id=studentInfo.id;
	```
 3. 根据某字段排序
	```sql
	#asc表示升序，默认升序；desc表示降序
	#studentInfo表中按照grade排序
	select * from studentInfo order by grade;
	select * from studentInfo order by grade desc;
	```
 4. 模糊查询
	```sql
	#like关键字是模糊查询的关键；%匹配任意0个以上字符；_匹配任意一个字符
	#查询student表中id中包含2020的所有数据
	select * from student where id like '%2020%';
	```

 ### Step5：修改信息
 1. 单表更新
	```sql
	#更新一个字段或多个字段
	update student set age=20,name='沈腾' where id=20200001;
	#如果不设置where条件限制，则该字段的所有元组均修改
	update student set age=20;
	#mysql支持数学表达式运算
	update student set age=age+1 where id=20200001;
	#数学表达式是从左到右进行运算
	update student set age=age/2,age=age+1 where id=20200001;
	```
 2. 多表更新
	```sql
	#更新学号为20200001的student和studentInfo内容
	update student,studentInfo set age=18,grade=96.9 where student.id=20200001 and student.id=studentInfo.id;
	```

 ### Step6: 删除信息
 ```sql
 #删除一行数据
 delete from student where id=20200002;
 #删除所有行
 delete from student;
 #删除一列数据
 alter table student drop column age; 
 #添加列字段
 alter table student add column age int(11);
 #删除表
 drop table student;
 #清空表
 truncate table student;
 ```

 ## 遇到的问题：
 1. MySql数据库创建表时字段名称无论用单引号还是双引号均报错
 	> 解决：字段应该使用反单引号包裹；而在mysql中字段的值使用引号包裹。
 2. 进入Docker容器内，无法输入中文字符
	> 原因：Docker容器系统所支持的字符集是POSIX字符集，此字符集不支持中文。
	>
	> 解决：进入Docker容器时设置系统的字符集为C.UTF-8;
	>-  docket exec -it 容器id env LANG=C.UTF-8 bash;

 # 实验二MongoDB学习
 ## Part1:MongoDB University 学习
**以下内容是在MongoDB官方网站下的MongoDB University下学习记录，由于初学，只是跟随课程进度操作，没有太多自己的总结。** 课程已经为新学者已经建立好一个Atlas集群，并存有一些数据供我们简单学习使用MongoDB操作语法。
 ### 工具概述
 - Mongo Atlas
	1. 它是网上一个提供界面的平台，在云提供商之间进行管理和部署MongoDB
	2. 它旨在启动和管理你的部署、简化运营的开销
 - Mongo Composs
	1. 提供图形用户界面，浏览数据库中的数据，快速查看数据结构、状态以及测试
	2. 优化查询性能、管理索引
 - Mongo Shell
	1. 是一个交互式JavaScript与MongoDB的接口
	2. 更好的理解MongoDB
 ### 安装Mongo Shell（Windows）
 - 本课程将使用Mongo Shell连接到Atlas集群，练习运行查询以及MongoDB数据库的交互
 - 教程分为18步详细介绍如何在Window下安装，此处不再做笔记，简单归纳
	1. 下载安装器
	2. 安装，基本是点击下一步
	3. 配置环境变量
	4. CMD命令行检验安装成功
 ### Atlas概述
 - Atlas是MongoDB的“数据库即服务”的解决方案
 - 提供云中设置数据库的功能，而无需自己配置详细信息，**手动使用命令行管理程序**
 - 维护冗余数据副本（分布式应用），增加可用性
 - 工作原理
	1. Atlas用户可以部署集群，是存储数据的一组服务器
	2. 这些服务器经过配置，副本集中的数据库存储相同的数据
	3. 即用户插入、更新数据时有冗余数据在集群中，减少丢失数据的可能
 - Atlas好处
	1. 设置简单
	2. 帮助管理创建的集群的详细信息，简化运营开销
	3. 界面化操作，方便管理云提供商之间部署MongoDB
	4. 具有MongoDB的新工具和功能
 - Atlas根据数据库大小和使用情况收费，又同时提供了永久性**三服务器副本集512M空间的免费套餐**
 ### 使用Compass来连接MongoDB
 - 下载安装Compass,非常简单
	>https://www.mongodb.com/try/download/compass
 - Compass提供两种连接已部署的集群
	1. 使用链接字符串
		> 本课程提供：mongodb+srv://m001-student:m001-mongodb-basics@cluster0-jxeqq.mongodb.net/test
	2. 填写部署的信息字段
		> 如果上述字符串无法连接则使用此方法，教程详细（https://university.mongodb.com/mercury/M001/2020_July_7/chapter/Chapter_0_Setup/lesson/594d8f1e8c07c3a9b60bdfb3/lecture）
 ### 使用Mongo Shell来连接课程提供的Atlas集群
 - 连接Atlas
	1. 使用PowerShell复制连接字符串(根据课程笔记，此链接有可能更改)
		> mongo "mongodb://cluster0-shard-00-00-jxeqq.mongodb.net:27017,cluster0-shard-00-01-jxeqq.mongodb.net:27017,cluster0-shard-00-02-jxeqq.mongodb.net:27017/test?replicaSet=Cluster0-shard-0" --authenticationDatabase admin --ssl --username m001-student --password m001-mongodb-basics
		>>mongo "mongodb://cluster0-shard-00-00-jxeqq.mongodb.net:27017,cluster0-shard-00-01-jxeqq.mongodb.net:27017,cluster0-shard-00-02-jxeqq.mongodb.net:27017;表示连接集群的三个服务器
		>>
		>>此后的/test,表示连接成功后进入哪个数据库
		>>
		>>后面的内容表示使用ssl加密协议，且输入用户名和密码
		>
		>[注]如果连接失败，参考下文的“遇到的问题”模块1
	2. 根据课程笔记提示，如果遇到以下错误，要在命令行中执行quit()退出Mongo Shell。
		>2019-01-11T13:35:53.633-0500 E QUERY [js] SyntaxError: missing ; before statement @(shell):1:6
	3. 本节提问的问题是：使用shell连接到Atlas集群时，为什么在启动mongo时提供所有节点的主机名？
		>回答：设计副本集的目的是，如果主节点发生故障，其他节点之一将升迁以取代其位置，以便客户端可以继续读取和写入数据，就像什么都没发生一样。
 - 对MongoDB集群的简单操作
	```sql
	#展示当前数据库的数据集
	show collections
	#没有显示，是因为上面连接默认进入test数据库，而通过Compass查看集群发现根本没有test数据库
	#更换数据库video,包含一个movies数据集
	use video
	#视频中演示下面的语句，显示了许多数据
	db.movies.find().pretty()
	```
### MongoDB基本了解
1. 三层结构，数据库(Databases)、集合(Collections)、文档(Documents)
2. 一般表述数据库下的集合会使用. ;例如video.movies
2. 数据库包含集合，集合内记录着多个文档
3. 文档类型使用Json格式保存，但在Mongo Compass中以键和值的形式展示。
4. MongoDB的数据格式非常灵活，支持自定义文档作为数据格式
5. 所有文件的类型和字段不必要一定相同，方便个别文件补充数据，对于查询时候的需要，我们要做摘要清单（一般使用数组实现）
### 课程学习到前两章，未完待续

## Part2:Docker安装MongoDB
在Ubuntu16.04的云服务器上安装MongoDB
- 使用Docker从中央仓库拉去MongoDB的镜像
	> docker pull mongo
- 查看镜像
	> docker images
- 创建并运行mongo容器
	> docker run -d -p 27017:27017 -v $pwd/mongodb/db:/data/db --name mongodb mongo
	>> -v $pwd/mongodb/db:/data/db 是把容器的/data/db挂在在服务器的当前目录下的/mongodb/db文件夹下
	>>
	>>执行这一步原因是mongodb在创建时不自动创建/data/db目录，但其数据库默认存储位置是/data/db，我们不希望容器内存储数据，所以挂在在宿主服务器上。
- 查看当前容器运行情况
	> docker ps
- 进入mongodb容器
	> docker exec -it mongodb env LANG=C.UTF-8 bash
- 使用mongodb命令行
	> mongo
- 使用admin数据库，并在其中创建root用户拥有全部权限
	>use admin
	>
	>db.createUser({user: 'root',pwd: '123456',roles: [{ role:"userAdminAnyDatabase", db: "admin" }]});
- 对root用户进行身份验证操纵数据库
	> db.auth("root","123456");
## Part3:MongoDB的基本操作
### Step1：创建数据库
1. 创建数据库使用 use dbName;如果dbName数据库存在则使用该数据库，否则创建新数据库
	```bash
	#创建数据库
	use school
	#查看当前使用的数据库
	db
	```
2. 数据库其他操作
	```bash
	#展示所有数据库
	show dbs
	#删除当前使用的数据库
	db.dropDatabase()
	```
### Step2:创建集合
1. 创建一个student集合
	```bash
	#创建student集合
	db.createCollection("student")
	```
2. 集合的其他操作
	```bash
	#查看已有的集合
	show collections
	#删除集合
	db.集合名.drop()   e.g: db.student.drop()
	#集合改名
	db.集合名.renameCollection("新名字")
	```
### Step3:文档操作
1. 插入文档</br>
	在MongoDB中，存储于集合中的每一个文档都需要一个唯一的 _id 字段作为 primary_key。如果一个插入文档操作遗漏了``_id`` 字段，MongoDB驱动会自动为``_id``字段生成一个 ObjectId。

	```bash
	#使用save()方法插入;若插入数据主键存在则更新数据，不存在则插入数据
	db.student.save({"name":"沈腾","sex":"男","age":38,"grade":98.05})
	#使用insert()方法插入，若插入数据主键存在则报错
	db.student.insert({"name":"宋小宝","sex":"男","age":48,"grade":88.05})
	#插入多条数据，返回BulkWriteResult对象
	db.student.insert([{name:"马丽",sex:"女",age:28,grade:79.90},
	{name:"常远",sex:"男",age:38,grade:80.88},{name:"艾伦",love:"baskball"}])
	#插入多条数据，返回一个结果文档
	db.student.insertMany([{name:"修睿",love:"swimming"},{name:"乔杉",age:48}])
	```
2. 查询文档
	```bash
	#查询指定集合所有文档
	db.student.find()
	#使用 pretty()方法来格式化文档
	db.student.find().pretty()
	#findOne()方法，它只返回一个文档
	db.student.findOne()
	#条件查询---------------------------------
	#单条件查询
	db.student.find({"name":"沈腾"}).pretty()
	#多条件查询
	db.student.find({"name":"沈腾","sex":"男"}).pretty()
	```
3. 更新文档
	```bash
	#updateOne()即使多个文档匹配了查询条件，最多也更新一个文档
	db.collection.updateOne(<先查询>,<后更新>)
	e.g: db.student.updateOne({name:"沈腾"},{$set:{age:18}})
	#updateMany()更新所有匹配查询结果的文档
	db.collection.updateMany(<先查询>,<后更新>)
	e.g: db.student.updateOne({name:"沈腾"},{$set:{age:18}})
	```
4. 删除文档
	```bash
	#deleteOne()即使多个文档匹配了查询条件，最多也删除一个文档
	db.student.deleteOne({name:"沈腾"})
	#deleteMany()删除所有匹配查询条件的文档
	db.student.deleteMany({name:"沈腾"})
	#删除所有文档，传入空条件
	db.student.deleteMany({})
	```

 ## 遇到的问题：
 1. 问题：课程笔记提供两个连接，使用powershell均无法连接且报错“服务器已吊销”
  	>解决：由笔记提供两个连接，且提示第一个连接无法使用可能因为协议语法不标准导致DNS服务商不支持，所以认定是DNS出错，于是更**改为谷歌的DNS服务器**便成功连接成功。(如何改计算机DNS可百度)
 2. 问题：创建的mongodb通过Compass远程访问，无需密码即可连接访问
	>解决：此行为是对数据库安全性的不负责任，解决方法是开启权限验证，即运行mongdb容器时加上权限验证 --auth
	>
	>docker run -d -p 27017:27017 -v $pwd/mongodb/db:/data/db --name mongodb mongo --auth
	>
	>再进入mongodb需要进入admin库中验证用户和密码才能使用数据库

# 实验三Redis的学习
Redis是一个Key-Value类型的内存数据库，整个数据库**加载在内存中进行操作**，定期通过异步操作把数据库flush到硬盘中保存
## Part1:Docker下载Redis
- 使用Docker从中央仓库中下载镜像
	>docker pull redis
- 查看下载下的镜像
	>docker images
- 创建运行容器
	>docker run -itd -p 6379:6379 -v $PWD/redis/data:/data redis redis-server --appendonly yes
	>>redis-server --appendonly yes 是在容器执行redis-server启动命令，并打开redis持久化配置
- 进入容器操作redis
	>docker exec -it redis redis-cli 

## Part2:Redis的学习
### Step1:基本了解
- 单机Redis默认有16个数据库，使用索引来表示，分别是0-15
	>更改数据库使用命令 select1 或 select8
- 数据库数量可以通过配置文件无上限增加
- **Redis集群中不支持多数据库**
- Redis有5种数据类型：字符串(string)、哈希(hash)、列表(list)、集合(set)、有序集合(zset)，每种数据类型都有对应的set/get命令。

### Step2:通用key命令的了解
1. 删除 del，不存在的key自动忽略
	```bash
	#删除一个key
	del key
	#删除多个key
	del key1 key2 key3
	```
2. exists key: 检查key是否存在
3. rename key newname: 修改key名，若可以不存在返回一个错误
	- newname存在的情况下，会覆盖旧的newname
	- 相当于删除旧的newname键值对，再对指定可以改名为newname
4. key *: 查看当前所有的key
5. random key: 随机返回一个key
6. type key: 返回key所存储的类型

### Step3:五中存储类型的基本操作
1. string的基本操作
	- SET key value：将字符串值 value 关联到 key 。
		- 如果 key 已经持有其他值， SET 就覆写旧值，无视类型。
	- SETNX key value：将 key 的值设为 value ，当且仅当 key 不存在。
		- 若给定的 key 已经存在，则 SETNX 不做任何动作。
	- GET key：返回 key 所关联的字符串值。
		- 如果 key 不存在那么返回特殊值 nil 。
		- 假如 key 储存的值不是字符串类型，返回一个错误，因为 **GET 只能用于处理字符串值**。
	- GETRANGE key start end：返回 key 中字符串值的子字符串
		- 字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。
		- 负数偏移量表示从字符串最后开始计数， -1 表示最后一个字符， -2 表示倒数第二个，以此类推。
	- MGET key [key ...]: 返回所有(一个或多个)给定 key 的值。
		- 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。因此，该命令永不失败。
		```bash
		#使用MGET
		mget name1 name2 name3 name4
		#结果展示
		1) "zhao"
		2) "qain"
		3) "sun"
		4) (nil)
		```
	- STRLEN key：返回 key 所储存的字符串值的长度。
		- 当 key 储存的不是字符串值时，返回一个错误。
	- APPEND key value：如果 key 已经存在并且是一个字符串，APPEND 命令将value追加到key原来的值的末尾。
		- 如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样。
		```bash
		#执行
		append name1 -hello
		#查询
		get name1
		#结果
		"zhao-hello"
		```

2. hash基本操作<br>
**hash通常用来存储一个对象的信息，例如在一个对象中包含字段名字、年龄、爱好等。**
	- HSET key field value：将哈希表 key 中的域 field 的值设为 value 。
		- 如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作。
		- 如果域 field 已经存在于哈希表中，旧值将被覆盖。
		```bash
		#创建一个user哈希表，并添加一个域名name
		hset user name wang
		```
	- HMSET key field value [field value ...]：同时将多个 field-value (域-值)对设置到哈希表 key 中。
		- 此命令会覆盖哈希表中已存在的域。
		- 如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作。
		```bash
		#在上一个user表中添加age和love
		hmset user age 18 love baskball
		```
	- HGET key field: 返回哈希表 key 中给定域 field 的值。
	- HMGET key field [field ...]: 返回哈希表 key 中，一个或多个给定域的值。
		- 如果给定的域不存在于哈希表，那么返回一个 nil 值。
		- 因为不存在的 key 被当作一个空哈希表来处理，所以对一个不存在的 key 进行 HMGET 操作将返回一个只带有 nil 值的表
	- HGETALL key: 返回哈希表 key 中，所有的域和值。
		- 在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。
		```bash
		#查询上述步骤存的user表
		hgetall user
		#结果展示
		1) "name"   #域名
		2) "wang"   #值
		3) "age"
		4) "18"
		5) "lova"
		6) "baskball"
		```
	- HKEYS key：返回哈希表 key 中的所有域。
	- HDEL key field [field ...]：删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略

3. list基本操作<br>
**list操作相当于对链表的操作，可以实现队或者栈的数据结构**
	- LPUSH key value [value ...]：将一个或多个值 value 插入到列表 key 的表头
		- 如果有多个 value 值，那么各个 value 值按从``左到右的顺序依次插入到表头``
		- 如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。
		- 当 key 存在但不是列表类型时，返回一个错误。
		```bash
		#插入1、2、3、4、5
		lpush num 1 2 3 4 5
		#查询结果如下，倒序插入
		1) "5"
		2) "4"
		3) "3"
		4) "2"
		5) "1"
		```
	- RPUSH key value [value ...]：将一个或多个值 value 插入到列表 key 的表尾(最右边)。
		- 如果有多个 value 值，那么各个 value 值按``从左到右的顺序依次插入到表尾``
		```bash
		#插入1、2、3、4、5
		rpush list 1 2 3 4 5
		#查询结果如下，正序插入
		1) "1"
		2) "2"
		3) "3"
		4) "4"
		5) "5"
		```
	- LPUSHX key value：将值 value 插入到列表 key 的``表头``，当且仅当 key 存在并且是一个列表。
		- 和 LPUSH 命令相反，当 key 不存在时， LPUSHX 命令什么也不做。
		```bash
		#key不存在执行lpushx
		lpushx test "hello"
		#结果是没有创建test
		----------------------
		#在上述list中插入
		lpushx list 6
		#结果展示
		1) "6"
		2) "1"
		3) "2"
		4) "3"
		5) "4"
		6) "5"
		```
	- RPUSHX key value：将值 value 插入到列表 key 的``表尾``，当且仅当 key 存在并且是一个列表。
		- 和 RPUSH 命令相反，当 key 不存在时， RPUSHX 命令什么也不做。
	- LLEN key: 返回列表 key 的长度。
		- 如果 key 不存在，则 key 被解释为一个空列表，返回 0 .
		- 如果 key 不是列表类型，返回一个错误。
	- **LRANGE key start stop**: 返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。
		- 下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。
		- 你也可以使用负数下标，以 ``-1表示列表的最后一个元素``， -2 表示列表的倒数第二个元素，以此类推。
	- LPOP key: 移除并返回列表 key 的头元素。
	- RPOP key: 移除并返回列表 key 的尾元素。

4. set基本操作<br>
**set集合是一个string类型的集合，且不允许有重复数据出现，以及元素无序**
	- SADD key member [member ...]: 将一个或多个 member 元素加入到集合 key 当中，``已经存在于集合的 member 元素将被忽略``。
		- 假如 key 不存在，则创建一个只包含 member 元素作成员的集合。
		- 当 key 不是集合类型时，返回一个错误。
		```bash
		#创建一个集合并添加元素
		sadd family mather father
		#重复添加会无反应
		sadd family mather
		#查看结果
		1) "mather"
		2) "father"
		```
	- SCARD key：返回集合 key 的基数(集合中元素的数量)。
		```bash
		#查询集合family数
		scard family
		#结果
		(integer) 2
		```
	- SMEMBERS key：返回集合 key 中的所有成员。
		- 不存在的 key 被视为空集合。
		```bash
		#查询不存在的集合
		smembers no
		#结果
		(empty array)
		#查询family集合
		smembers family
		#结果
		1) "mather"
		2) "father"
		```
	- SISMEMBER key member：判断 member 元素是否集合 key 的成员。
		- 如果 member 元素是集合的成员，返回 1 。
		- 如果 member 元素不是集合的成员，或 key 不存在，返回 0 
		```bash
		#查询mather是否在集合family
		sismember family mather
		#结果
		(integer) 1
		#查询sister是否在集合中
		sismember family sister
		#结果
		(integer) 0
		```
	- SREM key member [member ...]：移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。
		- 当 key 不是集合类型，返回一个错误。
	- SMOVE source destination member：将 member 元素从 source 集合移动到 destination 集合。
		- SMOVE 是原子性操作。
		- 如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。
		- 当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。
		- 当 source 或 destination 不是集合类型时，返回一个错误。
		```bash
		#从已存在的集合转移元素到未存在的集合，则创建集合
		smove family otherfamily father
		```
	- SDIFF key [key ...]：返回一个集合的全部成员，该集合是所有给定集合之间的差集。
		- 不存在的 key 被视为空集。
	- SDIFFSTORE destination key [key ...]：这个命令的作用和 SDIFF 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。
		- 如果 destination 集合已经存在，则将其覆盖。
  		- destination 可以是 key 本身。

5. zset基本操作
**zset同set一样是一个String类型的集合，且不允许有重复数据出现。但zset会为每个元素关联一个double类型的分数，redis通过分数对集合进行了``从小到大的排序``。这种集合是通过哈希表来实现。**
	- ZRANGE key start stop [WITHSCORES]：返回有序集 key 中，指定区间内的成员。
		- 其中成员的位置按 score 值递增(从小到大)来排序。
	- **ZADD key score member [[score member] [score member] ...]**：将一个或多个 member 元素及其 score 值加入到有序集 key 当中。
		- 如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。
		- score 值可以是整数值或双精度浮点数。
		- 如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。
		- 当 key 存在但不是有序集类型时，返回一个错误。
		```bash
		#创建一个有序集合，且添加成员
		zadd grade 90.5 java 88 python 79 html 86 dabase
		#查询该集合
		zrange grade 0 -1
		#结果展示
		1) "html"
		2) "dabase"
		3) "python"
		4) "java"
		#修改python分数
		zadd grade 60 python
		#再次查询结果展示
		1) "python"
		2) "html"
		3) "dabase"
		4) "java"
		```
	- ZCARD key：返回有序集 key 的基数。
	- ZCOUNT key min max：返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。
		```bash
		#查询70到90的数目
		zcount grade 70 90
		#结果
		(integer) 2
		```
	- ZREM key member [member ...]：移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。
		- 当 key 存在但不是有序集类型时，返回一个错误。


## 遇到的问题：
1. 问题：
	>解决：

 ## TODO：

 	- 
 	- 

