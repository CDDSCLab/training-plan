# 数据库实验

## 1 MySQL

### 2.1 安装MySQL

使用Docker安装MySQL

拉取官方镜像：

`docker pull mysql:latest`

运行容器：

`docker run -itd --name hl_test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=houlei mysql`

### 2.2 简单使用

运行docker中的MySQL容器：

`docker exec -it hl_mysql /bin/bash`

进入mysql：

`# mysql -u root  -p`

创建数据库：

`create databases hl_test;`

`use hl_test;`

建立一个student表和student_info表：

`mysql> create table student(
    -> id int primary key ,
    -> name varchar(20) ,
    -> sex varchar(8) default 'male' check(sex in ('male','female'))
    -> )；`

`mysql> create table student_info(
    -> id int primary key,
    -> chinese_score int unsigned not null,
    -> english_score int unsigned not null,
    -> math_score int unsigned not null,
    -> gym_score int unsigned not null
    -> );`

`alter table student_info add foreign key(id) references student(id);`

向表中插入信息：

`insert into student(id,name,sex) values(2001,'zhangsan','male');`

`insert into student(id,name,sex) values(2002,'lisi','female');`

`insert into student(id,name,sex) values(2003,'wangwu','female');`

`select * from student;`
`+------+----------+--------+`
`| id   | name     | sex    |`
`+------+----------+--------+`
`| 2001 | zhangsan | male   |`
`| 2002 | lisi     | female |`
`| 2003 | wangwu   | female |`
`+------+----------+--------+`

`insert into student_info(id,chinese_score,english_score,math_score,gym_score) values(2001,99,98,97,96);`

`insert into student_info(id,chinese_score,english_score,math_score,gym_score) values(2002,89,88,87,86);`

`insert into student_info(id,chinese_score,english_score,math_score,gym_score) values(2003,79,78,77,76);`

`select * from student_info;`
`+------+---------------+---------------+------------+-----------+`
`| id   | chinese_score | english_score | math_score | gym_score |`
`+------+---------------+---------------+------------+-----------+`
`| 2001 |            99 |            98 |         97 |        96 |`
`| 2002 |            89 |            88 |         87 |        86 |`
`| 2003 |            79 |            78 |         77 |        76 |`
`+------+---------------+---------------+------------+-----------+`

通过join查看id为2001的学生的所有分数信息：

 `select *  from student join student_info using(id) where student.id = 2001;`

`+------+----------+------+---------------+---------------+------------+-----------+`
`| id   | name     | sex  | chinese_score | english_score | math_score | gym_score |`
`+------+----------+------+---------------+---------------+------------+-----------+`
`| 2001 | zhangsan | male |            99 |            98 |         97 |        96 |`
`+------+----------+------+---------------+---------------+------------+-----------+`

### TODO

1.回忆一下基础知识

2.有机会多用用

## 2 MongoDB


### 创建数据库目录

MongoDB 的数据存储在 data 目录的 db 目录下，但是这个目录在安装过程不会自动创建，所以你需要手动创建 data 目录，并在 data 目录中创建 db 目录。

以下实例中我们将data目录创建于根目录下(/)。

注意： /data/db 是 MongoDB 默认的启动的数据库路径( --dbpath ) 。

```
mkdir -p /data/db
```

### 命令行中运行 MongoDB 服务

你可以再命令行中执行 mongo 安装目录中的 bin 目录执行 mongod 命令来启动 mongdb 服务。

> 注意：如果你的数据库目录不是 /data/db，可以通过 --dbpath 来指定。

```
$ ./mongod
2015-09-25T16:39:50.549+0800 I JOURNAL  [initandlisten] journal dir=/data/db/journal
2015-09-25T16:39:50.550+0800 I JOURNAL  [initandlisten] recover : no journal files present, no recovery needed
2015-09-25T16:39:50.869+0800 I JOURNAL  [initandlisten] preallocateIsFaster=true 3.16
2015-09-25T16:39:51.206+0800 I JOURNAL  [initandlisten] preallocateIsFaster=true 3.52
2015-09-25T16:39:52.775+0800 I JOURNAL  [initandlisten] preallocateIsFaster=true 7.7
```

### MongoDB 后台管理 Shell

如果你需要进入 MongoDB 后台管理，你需要先打开 mongodb 装目录的下的 bin 目录，然后执行 mongo 命令文件。

MongoDB Shell 是 MongoDB 自带的交互式 Javascript shell, 用来对 MongoDB 进行操作和管理的交互式环境。

当你进入 MongoDB 后台后，它默认会链接到 test 文档（数据库）：

```
$ cd /usr/local/mongodb/bin
$ ./mongo
MongoDB shell version: 3.0.6
connecting to: test
Welcome to the MongoDB shell.
……
```

由于它是一个 JavaScript shell，您可以运行一些简单的算术运算:

```
> 2+2
4
> 3+6
9
```

### 操作

第一个命令将数字 10 插入到 runoob 集合的 x 字段中。

```
> db.runoob.insert({x:10})
WriteResult({ "nInserted" : 1 })
> db.runoob.find()
{ "_id" : ObjectId("5604ff74a274a611b0c990aa"), "x" : 10 }
>
```

插入

```sql
#  插入单条数据

> var document = db.collection.insertOne({"a": 3})
> document
{
        "acknowledged" : true,
        "insertedId" : ObjectId("571a218011a82a1d94c02333")
}

#  插入多条数据
> var res = db.collection.insertMany([{"b": 3}, {'c': 4}])
> res
{
        "acknowledged" : true,
        "insertedIds" : [
                ObjectId("571a22a911a82a1d94c02337"),
                ObjectId("571a22a911a82a1d94c02338")
        ]
}
```

更新

```sql
db.col.update( { "count" : { $gt : 1 } } , { $set : { "test2" : "OK"} } );
db.col.update( { "count" : { $gt : 5 } } , { $set : { "test5" : "OK"} },true,true );
db.col.update( { "count" : { $gt : 10 } } , { $inc : { "count" : 1} },false,false );
```

删除

```sql
db.testList.remove({'name':'kkk is null'},1);
```

## 3 Redis 

### 概念：

1. 以key-value的方式存储，亦可支持list，set，zset，hash等数据结构。

2. 运行在内存中，读写速度极快。支持数据持久化，即将数据保存回磁盘。

3. 是一个数据结构服务器。value可以存储更为复杂的数据结构。Redis有5种基本的数据类型：字符串（strings）、哈希（hashes）、列表（list）、集合（sets）、有序集合（sorted sets），每种数据类型都有对应的set/get命令。

4. 单机数据库，数据库大小不能超过内存大小。一个redis实例默认支持16个数据库，以数字编号命名，更像是一个命名空间。

5. 可为key设置一个生存期。过期的key会自动销毁。

6. 其他数据类型：位图（bitmap）用于进行位操作，极大节省空间。HyperLogLog用于做基数估计。Geo用于存储地理位置信息。Stream用于消息队列。

### 使用docker搭建redis环境

#### 1. 拉取redis镜像：
```
 $ docker pull redis
```
#### 2. 运行容器：
```
 $ docker run -itd --name some-redis -p 6379:6379 redis
```
 参数说明：

 + some-redis为容器名。


#### 3. 连接容器：
```
$ docker exec -it some-redis /bin/bash
```
#### 4. 连接redis服务并测试数据库：

```
>/data# redis-cli
> 127.0.0.1:6379> set test 1
> OK
```

### 链接

+ try redis，一个可直接试用redis的免安装在线平台: https://try.redis.io/

+ 官方文档（数据类型介绍）:https://redis.io/topics/data-types-intro
+ 菜鸟教程：https://www.runoob.com/redis/redis-data-types.html

### 运行示例：

#### 哈希（hash）：
```
127.0.0.1:6379>  HMSET runoobkey name "redis tutorial" description "redis basic commands for caching" likes 20 visitors 23000
OK
127.0.0.1:6379>  HGETALL runoobkey
1) "name"
2) "redis tutorial"
3) "description"
4) "redis basic commands for caching"
5) "likes"
6) "20"
7) "visitors"
8) "23000"
```

#### 列表（list）：
```
127.0.0.1:6379> del runoobkey
(integer) 1
127.0.0.1:6379> lpush runoobkey redis
(integer) 1
127.0.0.1:6379> lpush runoobkey mongodb
(integer) 2
127.0.0.1:6379> rpush runoobkey mysql
(integer) 3
127.0.0.1:6379> lrange runoobkey 0 10
1) "mongodb"
2) "redis"
3) "mysql"
127.0.0.1:6379> lpop runoobkey
"mongodb"
127.0.0.1:6379> lrange runoobkey 0 -1
1) "redis"
2) "mysql"
127.0.0.1:6379> llen runoobkey
(integer) 2
127.0.0.1:6379>
```

#### 集合（set）：
```
127.0.0.1:6379> del runoobkey
(integer) 1
127.0.0.1:6379> sadd runoobkey redis
(integer) 1
127.0.0.1:6379> sadd runoobkey 1 2 3
(integer) 3
127.0.0.1:6379> sadd runoobkey mongodb
(integer) 1
127.0.0.1:6379> smembers runoobkey
1) "3"
2) "1"
3) "redis"
4) "2"
5) "mongodb"
127.0.0.1:6379> sismember runoobkey 3
(integer) 1
```
#### 有序集合（sorted set）：
```
127.0.0.1:6379> zadd hackers 1940 "Alan Kay"
(integer) 1
127.0.0.1:6379> zadd hackers 1957 "Sophie Wilson"
(integer) 1
127.0.0.1:6379> zadd hackers 1953 "Richard Stallman"
(integer) 1
127.0.0.1:6379> zadd hackers 1949 "Anita Borg"
(integer) 1
127.0.0.1:6379> zadd hackers 1965 "Yukihiro Matsumoto"
(integer) 1
127.0.0.1:6379> zadd hackers 1914 "Hedy Lamarr"
(integer) 1
127.0.0.1:6379>  zadd hackers 1916 "Claude Shannon"
(integer) 1
127.0.0.1:6379>  zrange hackers 0 -1
1) "Hedy Lamarr"
2) "Claude Shannon"
3) "Alan Kay"
4) "Anita Borg"
5) "Richard Stallman"
6) "Sophie Wilson"
7) "Yukihiro Matsumoto"
127.0.0.1:6379> zrangebyscore hackers -inf 1950
1) "Hedy Lamarr"
2) "Claude Shannon"
3) "Alan Kay"
4) "Anita Borg"
127.0.0.1:6379> zremrangebyscore hackers 1940 1960
(integer) 4
```
#### 命令总结：

###### 1. ```redis-cli``` 进入redis客户端

###### 2. 对于字符串（string）：
是 redis 最基本的类型，是二进制安全的。可以包含任何数据。比如jpg图片或者序列化的对象。
+ ```SET key value``` 设置或更新指定key的值，
+ ```GET key``` 获取指定key的值，
+ ```DEL key``` 在key存在的时候删除key和其关联值，
+ ```MSET key1 value1 key2 value2...``` 设置或更新多个值，
+ ```MGET key1 key2...``` 获取多个key所对应值，

+ ```EXIST key``` 返回key是否存在。

###### 3. 对于哈希（hash）：
是一个string类型的字段（field）和值（value）的映射表。
+ ```HMSET key field1 value1 [field2 value2]...``` 设置hash表，
+ ```HGET key field``` 获取指定field的值，

+ ```HGETALL key``` 获取指定key的所有字段和值。

###### 4. 对于列表（list）：
是简单的字符串列表，按照插入顺序排序。可以添加元素到列表的头部（左边）或者尾部（右边）。
+ ```LPUSH key element...``` 在列表左边添加元素，
+ ```RPUSH key element...``` 在列表右边添加元素，
+ ```LRANGE key index1 index2``` 返回索引之间的元素，index可为负，-1为最后一个元素，-2为倒数第二个元素。
+ ```LPOP/RPOP key``` 弹出一个列表元素，
+ ```BLPOP/BRPOP key``` 弹出元素的阻塞版本，当列表为空时会阻塞列表，直到有新元素添加至列表或超时，

+ ```LLEN key``` 获取列表长度。

应用例子：社交网络中获取最新的10篇文章或照片；生产者/消费者场景。

###### 5. 对于集合（set）：
是String类型的无序集合，集合中的元素是唯一的。通过哈希表实现，添加，删除，查找的复杂度都是O(1)。
+ ```SADD key ele1 ele2...``` 向集合添加元素，返回1为添加成功，0为集合的重复元素，
+ ```SMEMBERS key``` 返回集合所有元素，
+ ```SISMEMBER key element``` 查找某个元素是否在集合中，
+ ```SCARD key``` 获取集合的元素个数，
+ ```SPOP key``` 随机获取并移除一个元素,

+ ```SRANDMEMBER key n``` 随机返回集合中的n个元素。

应用例子：给新闻文章添加一组类型标签，扑克牌游戏。

###### 6. 对于有序集合（sorted set）：
和集合类似，不同的是每个元素都会关联一个double类型的分数，来为元素进行从小到大的排序。
+ ```ZADD key score ele``` 向有序集合添加元素及分数，
+ ```ZRANGE key index1 index2``` 返回元素，按索引（分数）排序，
+ ```ZRANGEBYSORCE key min max``` 返回分数在某个区间的元素，
+ ```ZRANGK key element``` 返回元素索引，

+ ```ZCARD key``` 返回集合的元素个数。

新特性：分数相同时按字母顺序排序。

### 遇到的问题：

### TODO：

 	-深入理解Redis数据库的架构和实现机制
 	-其他key-value型数据库学习

## 4 Janusgraph

### 4.1 安装janusgraph

参考https://docs.janusgraph.org/getting-started/installation/

需要先在docker中启动服务器并实例化，然后再为客户端启动容器

`docker run --name janusgraph-default janusgraph/janusgraph:latest`

`docker run --rm --link janusgraph-default:janusgraph -e GREMLIN_REMOTE_HOSTS=janusgraph \    -it janusgraph/janusgraph:latest ./bin/gremlin.sh`

#客户端连接的是--name服务器的名字

### 4.2 运行官方示例

加载诸神图：

`graph = JanusGraphFactory.open('conf/janusgraph-inmemory.properties')`

`GraphOfTheGodsFactory.loadWithoutMixedIndex(graph, true)`

#使用这种方式不需要配置index后端

在图数据库中访问数据最好的方式是先找一个入口：

该入口可以是点或边

`gremlin> saturn = g.V().has('name', 'saturn').next()`

`==>v[4136]`

通过valueMap查看saturn的属性：

`gremlin> g.V(saturn).valueMap()`
`==>[name:[saturn],age:[10000]]`

通过图中的关系查找saturn的孙子：

`gremlin> g.V(saturn).in('father').in('father').values('name')`
`==>hercules`

通过边属性查看发生在Athens周围50km的所有事件：

`gremlin>g.E().has('place', geoWithin(Geoshape.circle(37.97, 23.72, 50)))`

`==>e[5j5-360-7x1-6go][4104-battled->8376]`
`==>e[5xd-360-7x1-9ig][4104-battled->12328]`

`gremlin> g.V(4104).valueMap()`
`==>[name:[hercules],age:[30]]`
`gremlin> g.V(8376).valueMap()`
`==>[name:[nemean]]`
`gremlin> g.V(12328).valueMap()`
`==>[name:[hydra]]`

图索引（janusgraph会自动选择为边或点）：

`gremlin> g.E().has('place', geoWithin(Geoshape.circle(37.97, 23.72, 50))).as('source').inV().as('god2').select('source').outV().as('god1').select('god1', 'god2').by('name')`

`==>[god1:hercules,god2:nemean]`
`==>[god1:hercules,god2:hydra]`

使用loop简化查询：

`gremlin> hercules = g.V(saturn).repeat(__.in('father')).times(2).next()`
`==>v[4104]`

查询hercules父母的属性：

`gremlin> g.V(hercules).out('father', 'mother')`
`==>v[4152]`
`==>v[8232]`
`gremlin> g.V(hercules).out('father', 'mother').values('name')`
`==>jupiter`
`==>alcmene`
`gremlin> g.V(hercules).out('father', 'mother').label()`
`==>god`
`==>human`
`gremlin> hercules.label()`
`==>demigod`

查询hercules参与的战争：

`gremlin> g.V(hercules).out('battled')`
`==>v[8376]`
`==>v[12296]`
`==>v[12328]`
`gremlin> g.V(hercules).out('battled').valueMap()`
`==>[name:[nemean]]`
`==>[name:[cerberus]]`
`==>[name:[hydra]]`
`gremlin> g.V(hercules).outE('battled').has('time', gt(1)).inV().values('name')`
`==>cerberus`
`==>hydra`
`gremlin> g.V(hercules).outE('battled').has('time', gt(1)).inV().values('name').toString()`
`==>[GraphStep(vertex,[v[4104]]), VertexStep(OUT,[battled],edge), HasStep([time.gt(1)]), EdgeVertexStep(IN), PropertiesStep([name],value)]`

一些查询实例：

`gremlin> pluto = g.V().has('name', 'pluto').next()`
`==>v[8200]`
`gremlin> g.V(pluto).out('lives').in('lives').values('name')`
`==>pluto`
`==>cerberus`
`gremlin>  g.V(pluto).out('lives').in('lives').where(is(neq(pluto))).values('name')`
`==>cerberus`
`gremlin> g.V(pluto).as('x').out('lives').in('lives').where(neq('x')).values('name')`
`==>cerberus`



`gremlin>  g.V(pluto).out('brother').out('lives').values('name')`
`==>sky`
`==>sea`
`gremlin> g.V(pluto).out('brother').as('god').out('lives').as('place').select('god', 'place')`
`==>[god:v[4152],place:v[4256]]`
`==>[god:v[4280],place:v[4232]]`
`gremlin> g.V(pluto).out('brother').as('god').out('lives').as('place').select('god', 'place').by('name')`
`==>[god:jupiter,place:sky]`
`==>[god:neptune,place:sea]`



`gremlin> g.V(pluto).outE('lives').values('reason')`
`==>no fear of death`
`gremlin> g.E().has('reason', textContains('loves'))`
`08:57:14 WARN  org.janusgraph.graphdb.transaction.StandardJanusGraphTx  - Query requires iterating over all vertices [(reason textContains loves)]. For better performance, use indexes`
`==>e[2dj-37c-9hx-3a8][4152-lives->4256]`
`==>e[36f-3aw-9hx-39k][4280-lives->4232]`

`gremlin> g.E().has('reason', textContains('loves')).as('source').values('reason').as('reason').select('source').outV().values('name').as('god').select('source').inV().values('name').as('thing').select('god', 'reason', 'thing')`

`==>[god:jupiter,reason:loves fresh breezes,thing:sky]`
`==>[god:neptune,reason:loves waves,thing:sea]`

### TODO：

1.实现一些更复杂的查询，感受一下janusgraph的神奇

