# 实验一 MySQL的安装和使用

## Step1：安装与增加root用户

 1. mysql的安装

    ```bash
    apt install mysql-server
    ```

    这里会自动安装mysql的最新版本

    ![mysql安装成功](https://i.loli.net/2020/07/07/6zwRG5cNdXHWuVp.png)
    
    可以看到安装成功
    
 1.  mysql新增root用户

    百度说可以直接使用`mysql -u root -p`回车进入mysql,但是我尝试了是不行的。

    ```bash
    mysql_secure_installation
    ```

    使用以上命令为root用户更改密码

    ```
    Securing the MySQL server deployment.
    
    Enter password for user root: 
    
    VALIDATE PASSWORD COMPONENT can be used to test passwords
    and improve security. It checks the strength of password
    and allows the users to set only those passwords which are
    secure enough. Would you like to setup VALIDATE PASSWORD component?
    
    Press y|Y for Yes, any other key for No: n
    Using existing password for root.
    Change the password for root ? ((Press y|Y for Yes, any other key for No) : y
    
    New password: 
    
    Re-enter new password: 
    By default, a MySQL installation has an anonymous user,
    allowing anyone to log into MySQL without having to have
    a user account created for them. This is intended only for
    testing, and to make the installation go a bit smoother.
    You should remove them before moving into a production
    environment.
    
    Remove anonymous users? (Press y|Y for Yes, any other key for No) : y
    Success.
    
    
    Normally, root should only be allowed to connect from
    'localhost'. This ensures that someone cannot guess at
    the root password from the network.
    
    Disallow root login remotely? (Press y|Y for Yes, any other key for No) : n
    
     ... skipping.
    By default, MySQL comes with a database named 'test' that
    anyone can access. This is also intended only for testing,
    and should be removed before moving into a production
    environment.
    
    
    Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y
     - Dropping test database...
    Success.
    
     - Removing privileges on test database...
    Success.
    
    Reloading the privilege tables will ensure that all changes
    made so far will take effect immediately.
    
    Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y
    Success.
    
    All done! 
        
    ```

    修改后输入密码成功进入mysql

    ![mysql进入成功](https://i.loli.net/2020/07/07/Rk8XjlEYospZzDw.png)

## Step2：Mysql基本命令使用

```sql
CREATE DATABASE IF NOT EXISTS lab
	DEFAULT CHARACTER SET UTF8
	COLLATE UTF8_GENERAL_CI;#指定排序

USE lab;

DROP TABLE IF EXISTS student;

CREATE TABLE student 
(
	id int(11),
	name varchar(20),
	age int(11),
	PRIMARY KEY(id)
)
 ENGINE=InnoDB
 DEFAULT CHARSET =utf8;


DROP TABLE IF EXISTS student_info;

CREATE TABLE student_info
(
	id int(11),
	identity char(18),
	class varchar(20),
	address varchar(200),
	PRIMARY KEY(id),
	KEY fk_id (id),
	CONSTRAINT fk_id FOREIGN KEY (id) REFERENCES student(id)
	ON DELETE CASCADE ON UPDATE CASCADE

)
 ENGINE=InnoDB
 DEFAULT CHARSET =utf8;
INSERT INTO student (id,name,age) values (11111,'fanqie',22);
INSERT INTO student_info (identity,id,class,address) values ('320555192303341918',11111,'一班','电子科技大学');
select student.id,class,identity,address,name,age from student ,student_info as info where student.id=info.id AND student.id=11111;
```

## 遇到的问题：

xxx

## TODO：

 	- 
 	- 

# 实验二 Mongodb的安装和使用

## Step 1 Mongodb介绍与安装

   2. 存储结构介绍

         1. ObjectId
                Mongodb自身提供ObjectId,如果在创建时不自己提供id，它会根据所在服务器进程和时间生成id,相比于Mysql提供的自增id，避免在大量访问的时候必须顺序插入来保证id的唯一的缺点。

         2. 数据结构层次

            Mongodb中数据库的存储分为三个层次，database,colletction和document。每一个数据库会有自己的文件夹，数据的文件内部被分为多个块，集合存储着文档。mongodb中最大的名称空间为集合，mongodb每一个索引对应着一个名称空间。在内部存储中集合和索引的存储是相似的。Mongodb底层数据结构为B树。

3. Mongodb安装

   ```bash
   sudo apt install mongodb
   ```

   在ubuntu下会进行自动的安装，并且设置自启动

   

## Step 2 Mongodb的基本使用

1. Mongodb数据类型

   1. Json

      Json是一种存储交换数据格式的文件，它可以包含字典，字符串，数组等数据。在Mongodb中，可以直接将Json数据转化为对应的document存入mongodb之中。

   2. Mongodb数据类型

      1. document:也称Object,字典类型
      
      2. Array:数组类型，可以方便的对于数组进行过滤操作
   
 1. CDUR
    
      
# 实验三 JanusGraph的安装和使用

## Step 1 JanusGraph安装

这里使用的是docker进行的安装，

```bash
docker run --name janusgraph-default janusgraph/janusgraph:latest
```

这会自动安装并且启动janugraph server,

```bash
docker run --rm --link janusgraph-default:janusgraph -e GREMLIN_REMOTE_HOSTS=janusgraph \
    -it janusgraph/janusgraph:latest ./bin/gremlin.sh
```

将client连接到server上



# 实验四 Redis的安装和使用

## Step1 Redis安装

redis在ubuntu下进行安装使用

```bash
sudo apt-get install redis-server
```

## Step2 Redis的初步使用

1. 启动命令行

   ```sh
    redis-cli -h 127.0.0.1 -p 6379
   ```

2. 字符串类型

   1. SET/GET命令

      redis的key为String类型，同时String也是redis的基本类型之一，一般来说redis的String类型长度不能超过512MB

      ```sh
      	set key value [expiration EX seconds|PX milliseconds] [NX|XX]
      ```

      set命令格式如上，key为关键字，value为值，expiration为过期时间，nx,xx分别是在key存在时不更改和存在时不更改。

      ```sh
      get key
      ```

      get用于获取对应的key值

   	```sh
   	127.0.0.1:6379> set mykey somevalue
   	OK
   	127.0.0.1:6379> get mykey
   	"somevalue"
   	127.0.0.1:6379> set mykey newvalue
   	OK
   	127.0.0.1:6379> get mykey
   	"newvalue"
   	127.0.0.1:6379> set mykey newvalue nx#存在更改失败
   	(nil)
   	127.0.0.1:6379> set mykey newvalue xx#存在更改成功
   	OK
   	127.0.0.1:6379> set newkey newvalue xx#不存在更改失败
   	(nil)
   	127.0.0.1:6379> set newkey newvalue nx#不存在更改成功
   	OK
   	```

   3. INCR/DECR/INCRBY/DECRBY

      ```sh
      127.0.0.1:6379> set counter 100
      OK
      127.0.0.1:6379> incr counter
      (integer) 101
      127.0.0.1:6379> incrby counter 50
      (integer) 151
      127.0.0.1:6379> DECR counter
      (integer) 150
      127.0.0.1:6379> DECRBY counter 50
      (integer) 100
      127.0.0.1:6379> incr mykey
      (error) ERR value is not an integer or out of range 
      ```

      以上四个命令都是对于Integer类型的值进行操作，对于非Integer类型的值操作会报错，以上几个命令都是原子性的
      
   3. MSET/MGET

      ```sh
      127.0.0.1:6379> mset a 10 b 20 c 30
      OK
      127.0.0.1:6379>  mget a b c
      1) "10"
      2) "20"
      3) "30"
      ```

      MSET和MGET用于批量化的赋值和获取值

   4. EXIST/DEL/TYPE

      ```sh
      127.0.0.1:6379> exists mykey newkey
      (integer) 2
      127.0.0.1:6379> del mykey
      (integer) 1
      127.0.0.1:6379> exists mykey newkey
      (integer) 1
      ```

      exists返回值为所查询的key存在的数目，del为删除成功的数目

      ```sh
      127.0.0.1:6379> type newkey
      string
      127.0.0.1:6379> del newkey
      (integer) 1
      127.0.0.1:6379> type newkey
      none
      ```

      type返回的是数据的类型，查询不存在的值返回的类型为none。

   5. 过期时间

      ```sh
      127.0.0.1:6379> set key som-value
      OK
      127.0.0.1:6379> expire key 5
      (integer) 1
      127.0.0.1:6379> get key
      "som-value"
      127.0.0.1:6379> get key
      (nil)
      127.0.0.1:6379> ttl key
      (integer) -2
      127.0.0.1:6379> set key 100 ex 10
      OK
      127.0.0.1:6379> ttl key
      (integer) 7
      127.0.0.1:6379> set key 100 px 10000000
      OK
      127.0.0.1:6379> ttl key
      (integer) 9998
      127.0.0.1:6379> pttl key
      (integer) 9913147
      ```

      ttl返回的是离过期还有多少，单位为秒，对于已经过期或者不存在的key返回的为-2,如果需要以毫秒进行获取可以使用pttl进行。

3. List类型

   redis类型的List时线性表类型，对于基于下标的访问速度较慢但是插入较快

   1. LPUSH/RPUSH

      LPUSH意味着将数据放在最左边（放在头），RPUSH则意味着将数据放在最右边（放在尾）。

      ```sh
      127.0.0.1:6379> rpush mylist A
      (integer) 1
      127.0.0.1:6379> rpush mylist B
      (integer) 2
      127.0.0.1:6379> lpush mylist first
      (integer) 3
      127.0.0.1:6379> lrange mylist 0 -1
      1) "first"
      2) "A"
      3) "B"
      ```

      LRANGE 用于显示List内的内容，格式如下

      ```sh
      lrange key start stop
      ```

      LPUSH和RPUSH也可以一次增加多个值

      ```sh
      127.0.0.1:6379> rpush mylist 1 2 3 4 5 "foo bar"
      (integer) 9
      127.0.0.1:6379> lpush mylist 1 2 3 4 5 "foo bar"
      (integer) 15
      ```

   2. RPOP/LPOP

      ```sh
      127.0.0.1:6379> rpush mylist a b c
      (integer) 3
      127.0.0.1:6379> rpop mylist
      "c"
      127.0.0.1:6379> rpop mylist
      "b"
      127.0.0.1:6379> rpop mylist
      "a"
      127.0.0.1:6379> rpop mylist
      (nil)
      ```

      RPOP用于删除列表中的值，当列表中的值数目为0时，返回null。

   3. LTRIM

      ```sh
      127.0.0.1:6379> rpush mylist 1 2 3 4 5
      (integer) 5
      127.0.0.1:6379> ltrim mylist 0 2
      OK
      127.0.0.1:6379> lrange mylist 0 -1
      1) "1"
      2) "2"
      3) "3"
      ```

      LTRIM用于提取出子数组。

   4. BRPOP

      ````sh
      127.0.0.1:6379> brpop tasks 5
      (nil)
      (5.05s)
      127.0.0.1:6379> lpush tasks tasks frist
      (integer) 2
      127.0.0.1:6379> brpop tasks 5
      1) "tasks"
      2) "tasks"
      127.0.0.1:6379> lrange tasks 0 -1
      1) "frist"
      ````

      BRPOP用于提取数组中的数据，BRPOP提取的数据是阻塞的，最后一个数组指定阻塞多久，如果到了指定的时间仍没有数据的话，返回null。

      与RPOP不同，BRPOP是按照阻塞顺序执行，且执行完成后，会返回一个key和value。

4. RedisHashes

   1. 赋值与取值

      ```sh
      hmset key field value [field value ...]
      hmget key field [field ...]
      ```

      hmset第一个field为key，其他的field为value,hmget也是以第一个field为key，其他为value。如果后续field指定了不存在的field则为null。

      ```sh
      127.0.0.1:6379> hmset user:1000 username antirez birthyear 1977 verified 1 
      OK
      127.0.0.1:6379> hgetall user:1000 
      1) "username"
      2) "antirez"
      3) "birthyear"
      4) "1977"
      5) "verified"
      6) "1"
      127.0.0.1:6379> hget user:1000 username
      "antirez"
      127.0.0.1:6379> hmget user:1000 username xxx
      1) "antirez"
      2) (nil)
      ```

      hgetall获取key的全部value,hget获取一个指定的value,hmget获取多个指定的value。

      ```sh
      127.0.0.1:6379> hincrby user:1000 birthyear 10
      (integer) 1987
      ```

      hincrby用于更改属性中的int值。

      ```sh
      127.0.0.1:6379> hmset user:1000 username xxx no_such_field yes
      OK
      127.0.0.1:6379> hgetall user:1000
      1) "username"
      2) "xxx"
      3) "birthyear"
      4) "1987"
      5) "verified"
      6) "1"
      7) "no_such_field"
      8) "yes"
      ```

      对于一个已存在的key进行赋值时，如果key存在会更改key的值，如果key不存在则会新建key的值。

5. Set

   1. 赋值与获取

      ```sh
      127.0.0.1:6379> sadd myset 1 2 3
      (integer) 3
      127.0.0.1:6379> smembers myset
      1) "1"
      2) "2"
      3) "3"
      ```

      sadd为key新增值，smembers获取值。

   2. 获取交集

      ```sh
      127.0.0.1:6379> sinter news:1000:tags myset
      1) "1"
      2) "2"
      ```

      sinter指定多个set获取他们的交集

   3. 弹出和批量赋值

      ```sh
      127.0.0.1:6379> sadd deck C1 C2 C3 C4 C5 C6 C7 C8 C9 C10 CJ CQ CK
      (integer) 13
      127.0.0.1:6379> sunionstore game:1:deck deck
      (integer) 13
      127.0.0.1:6379>  spop game:1:deck
      "C2"
      127.0.0.1:6379>  spop game:1:deck
      "C5"
      127.0.0.1:6379>  spop game:1:deck
      "C3"
      127.0.0.1:6379> scard game:1:deck
      (integer) 10
      127.0.0.1:6379> scard deck
      (integer) 13
      ```

      sunionstore 可以批量将一个set中的值赋值给另一个set，spop从set中随机弹出值，这种弹出不会影响到原来的set，scard统计给定key的长度。

6. 有序集合

   1. 增加/获取

      ```sh
      127.0.0.1:6379> zadd hackers 1940 "Alan Kay"
      (integer) 1
      127.0.0.1:6379> zadd hackers 1957 "Sophie Wilson"
      (integer) 1
      127.0.0.1:6379> zadd hackers 1953 "Richard Stallman"
      (integer) 1
      127.0.0.1:6379>  zadd hackers 1949 "Anita Borg"
      (integer) 1
      127.0.0.1:6379> zadd hackers 1965 "Yukihiro Matsumoto"
      (integer) 1
      127.0.0.1:6379> zadd hackers 1914 "Hedy Lamarr"
      (integer) 1
      127.0.0.1:6379> zadd hackers 1916 "Claude Shannon"
      (integer) 1
      127.0.0.1:6379>  zadd hackers 1969 "Linus Torvalds"
      (integer) 1
      127.0.0.1:6379> zadd hackers 1912 "Alan Turing"
      (integer) 1
      127.0.0.1:6379> zadd hackers 1912 "Alan Turig"
      (integer) 1
      127.0.0.1:6379> zrange hackers 0 -1
       1) "Alan Turig"
       2) "Alan Turing"
       3) "Hedy Lamarr"
       4) "Claude Shannon"
       5) "Anita Borg"
       6) "Richard Stallman"
       7) "Alan Kay"
       8) "Sophie Wilson"
       9) "Yukihiro Matsumoto"
      10) "Linus Torvalds"
      127.0.0.1:6379> zadd hackers 1957 "Alan Kay"
      (integer) 0
      ```

      zadd为所增添的值指定一个scores,对于同一个 scores可以指定多个值，但是对于同一个值不可以指定多个scores.

      zrange用于对于值的获取。

      ```sh
      127.0.0.1:6379> zrange hackers 0 -1 withscores
       1) "Alan Turig"
       2) "1912"
       3) "Alan Turing"
       4) "1912"
       5) "Hedy Lamarr"
       6) "1914"
       7) "Claude Shannon"
       8) "1916"
       9) "Anita Borg"
      10) "1949"
      11) "Richard Stallman"
      12) "1953"
      13) "Alan Kay"
      14) "1957"
      15) "Sophie Wilson"
      16) "1957"
      17) "Yukihiro Matsumoto"
      18) "1965"
      19) "Linus Torvalds"
      20) "1969"
      ```

      也可以带scores进行显示。

   2. 其余操作

      1.  zrangebyscore 

         ```sh
         127.0.0.1:6379>  zrangebyscore hackers -inf 1950
         1) "Alan Turig"
         2) "Alan Turing"
         3) "Hedy Lamarr"
         4) "Claude Shannon"
         5) "Anita Borg"
         ```

         获取socres大于某个值得数据集。

      2. zremrangebyscore

         ```sh
         127.0.0.1:6379> zremrangebyscore hackers 1940 1960
         (integer) 4
         127.0.0.1:6379> zrange hackers 0 -1 withscores
          1) "Alan Turig"
          2) "1912"
          3) "Alan Turing"
          4) "1912"
          5) "Hedy Lamarr"
          6) "1914"
          7) "Claude Shannon"
          8) "1916"
          9) "Yukihiro Matsumoto"
         10) "1965"
         11) "Linus Torvalds"
         12) "1969"
         ```

         删除在1940到1960之间的值

      3. zrank/zrevrank

         ```sh
         127.0.0.1:6379> zrank hackers "Alan Turig"
         (integer) 0
         127.0.0.1:6379>  zrevrank hackers "Alan Turig"
         (integer) 3
         ```

         zrank返回在从小到大排序的位置，zrevrank返回从小到大排序的位置。

      4. zrangebylex

         ```sh
         127.0.0.1:6379> zadd hackers 0 "B" 0 "C" 0 "A" 0 "D" 0 "D"
         (integer) 4
         127.0.0.1:6379> zrangebylex hackers [B [C
         1) "B"
         2) "C"
         ```

         获取value在所指定范围内的值。

7. Bitmaps

   bitmaps本身不是一种数据类型，它本身就是字符串，它可以对于字符串的位进行操作。

   ```sh
   127.0.0.1:6379> setbit key 10 1
   (integer) 0
   127.0.0.1:6379> setbit key 11 0
   (integer) 0
   ```

   setbit 是对与字符串指定的为进行操作，在第一条命令中就是将字符串的第十位赋值为了1，而第二条命令则是将字符串第十一位赋值为了0。

   ```sh
   127.0.0.1:6379> setbit key 10 1
   (integer) 0
   127.0.0.1:6379> setbit key 11 0
   (integer) 0
   127.0.0.1:6379> setbit key 13 1
   (integer) 0
   127.0.0.1:6379> bitcount key 
   (integer) 2
   ```

   bitcount用于统计key中为1的数组位的个数。用bitmaps可以方便的统计比如一天内的访问人数等信息。

8.  HyperLogLogs

   HyperLoglogs用于基数统计，即统计一个输入中不同值的个数，HyperLoglogs的特点是只需要消耗极少的空间便可以完成统计。

   ```sh
   127.0.0.1:6379> PFADD key 1 2 3 3 4 4
   (integer) 1
   127.0.0.1:6379> pfcount key
   (integer) 4
   ```

   PFADD 为指定key中添加值，pfcount统计不同个数的值。

